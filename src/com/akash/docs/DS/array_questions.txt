linked list
tree --> segment tree, interval tree
graph
DP
array  --> helping DS in array questions
        (Stack, Queue, Map, Set, Heap, BST, segment tree, interval tree, bits, sorting algo, 2D-array)

DS implementation in java

queue -> LinkedList
stack -> Stack
heap -> PriorityQueue
map -> HashMap
set -> HashSet
TreeMap -> BST (RB tree)
TreeSet -> BST (RB tree)


Queue<Integer> queue = new LinkedList<>(); // poll(), add()
Queue<Integer> minHeap = new PriorityQueue<Integer>(); // poll(), add()
Queue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());


=================================

Array

=>sorting algo
->bubble
->selection
->insertion

find minimum and maximum element in an array (bubble, selection)

->merge sort
merging two sorted arrays
merging two sorted linked list
merging two sorted linked list without using extra space
count number of inversions

->quick sort
sort array of 0 and 1
sort array of 0 1 and 2
segregate numbers smaller and larger than x


->Heap sort
merge k sorted arrays
place 1 farthest from 0 in an array of 0 and 1
Median of Stream of Running Integers
Connect n ropes with minimum cost
Kth Smallest/Largest Element in Unsorted Array
Kth smallest element in a row-wise and column-wise sorted 2D array


->couting sort
lexicographicaly maximum string

a X b = LCM(a,b) X HCF(a,b)

HCF
-> rotation of an array using reversal
-> find common matching time for diff time intervals (fountain problem)

=> array sum problem

Find all triplets with zero sum
Given an array A[] and a number x, check for pair in A[] with sum as x
Find a triplet that sum to a given value
Find a triplet in an array whose sum is closest to a given number
Maximum value of expression (arr[i] + arr[j] * arr[k]) formed from a valid Triplet
	such that arr[i] < arr[j] < arr[k] and i < j < k
	-> maintain 2 arrays of min number in left and max number in right
Find a triplet such that sum of two equals to third element
Find triplet with minimum sum

=> sum , diff problem, stock buy sell problem

max diff in an array arr, max of (arr[j] - arr[i]), j>i
substring sum problem
substring sum problem without taking adjacent
max diff bw numbers without taking adjacent from left to right
Stock buy and sell problem
maximum profit by buying and selling a stock at most twice
given an array arr find the maximum j-i such that arrj arri


minimum broadcast range required by m towers to reach n houses


Largest Sum Contiguous Subarray
Maximum Sum Increasing Subsequence
Longest increasing Subsequence


Segment tree
Interval tree


=>binary search
find pivot element in sorted and rotated array
sorted array with all elements having 2 occurence except 1 element, find that element
majority element in a sorted array


=> stack questions

check if Parenthesis are correct or not, [{{}}]({})
reverse stack using recursion
sort stack using recursion
queue using stack
Design a stack with operations on middle element
stack with get min on constant time
Next Greater Element
The Stock Span Problem
Largest Rectangular Area in a Histogram
	-> use segment tree , time = O(N.logN)
	-> nearest min in left and nearest min in right
		Find the nearest smaller numbers on left side in an array
histogram with water
	-> max index of left and right

=======================

// Find all triplets with zero sum
List<List<Integer>> threeSumToZero(int[] nums) {
	if(nums.length < 3) {
            return new ArrayList<>();
        }
	Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        for (int i=0; i<n-1; i++)
        {
            // initialize left and right
            int l = i + 1;
            int r = n - 1;
            int x = nums[i];
            while (l < r)
            {
                if (x + nums[l] + nums[r] == 0)
                {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[l]);
                    temp.add(nums[r]);
                    result.add(temp);

                    l++;
                    r--;
                } else if (x + nums[l] + nums[r] < 0) {
                    l++;
                } else {
                    r--;
                }
            }
        }
        return result;
}



// max diff in an array arr, max of (arr[j] - arr[i]), j>i

5 2 7 1 3 9
ans : 8

int maxDiff(int arr[]) {
	int minTillNow = arr[0];
	int maxDiff = 0;
	for(int i=1; i<arr.length; i++) {
		if(arr[i] - minTillNow > maxDiff) {
			maxDiff = arr[i] - minTillNow;
		}
		if(minTillNow > arr[i]) {
			minTillNow = arr[i];
		}
	}
	return maxDiff;
}



// maximum profit by buying and selling a stock at most twice




=================================

====>Array Rotations :

rotate array by d elements 
	->gcd way
	->left reversal algo
	->right reversal algo
find pivot element in sorted and rotated array
find sum of pair of numbers in sorted and rotated array
	->sorting  --	O(n^2)
	->hashing  --	O(n)
Find a triplet that sum to a given value
Find all triplets with zero sum
	->sorting then pick one and do sorting approach of 2  --	O(n^2)
	->store sum-A[i] in hashset, check if sum of every pair exist in hashset  --	O(n^2)
Find four elements that sum to a given value
	->create an array of sum of each pair,sort it,approach of 2 -- O(n^2.log n)

find pair of number having sum less than K
find triplets having sum less than k
Closest product pair in an array	

majority element	-> hashmap, moore voting algo
--majority element in a sorted array
Lexicographically minimum string rotation	-> array of size 26,count occurence of character from A-Z
--Rotate Matrix Elements (shift all elements by 1)
--Print a given matrix in spiral form
--Inplace rotate square matrix by 90 degrees -> rotate -> transpose
--TODO--Rotate each ring of matrix anticlockwise by K elements
Check if all rows of a matrix are circular rotations of each other -> append array to array itself
Minimum rotations required to get the same string -> same as above
Check if strings are rotations of each other or not
	->kmp
Count rotations divisible by 4

maximum sum in an array without adjacent elements
Minimum broadcast range required by M towers to reach N houses
Count minimum number of fountains to be activated to cover the entire garden
-> Input : arr1 = {2, 3, 10, 6, 4, 8, 1}
   Output : 8
   max diff bw two elements
   larger element appears after smaller element

====>Array rearrangement
Rearrange an array such that arr[i] = i
Move all negative numbers to beginning and positive to end
Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i
Convert array into Zig-Zag fashion
Rearrange array in alternating positive & negative items with O(1) extra space  -> quick sort logic
Rearrange array such that even positioned are greater than odd
Rearrange an array such that �arr[j]� becomes �i� if �arr[i]� is �j�
Arrange given numbers to form the biggest number
Longest Bitonic Subsequence  -> DP
Longest Bitonic SubArray	-> O(n) time, O(1) space
Maximum Sum Increasing Subsequence (positive numbers)
	->similar to longest increasing subsequence

--Minimum swaps required to bring all elements less than or equal to k together
--Find a sorted subsequence of size 3 in linear time
--Largest subarray with equal number of 0s and 1s



====>Optimization Problems :
--Find the smallest positive integer value that cannot be represented as sum of any subset of a given array
Smallest subarray with sum greater than a given value

--Print all subarrays with 0 sum
max sum subarray
max sum subarray without adjacent
max diff in an array of integers, such that A[j] > A[i] and j>i

Find subarray with given sum (Nonnegative Numbers)
--Find subarray with given sum (array having negative numbers)
print all permutations of a given string
print all subsequences of a string 

--create and store segment tree

====> stack questions

check is Parenthesis are correct or not
reverse stack using recursion
sort stack using recursion
queue using stack
Design a stack with operations on middle element
stack with get min on constant time
Next Greater Element
The Stock Span Problem
Largest Rectangular Area in a Histogram
	-> use segment tree , time = O(N.logN)
	-> nearest min in left and nearest min in right
		Find the nearest smaller numbers on left side in an array
histogram with water
	-> max index of left and right

===>binary search problems

Contains (True or False)
Index of first occurrence of a key
Index of last occurrence of a key
Index of least element greater than key
Index of greatest element less than key

pivot element in a sorted and rotated array
maximum occurence in a sorted array


===>divisibility problems 

all subsets in a set divisible by k
Count all sub-arrays having sum divisible by k
Longest subarray with sum divisible by k


===> Heap problems

K�th Smallest/Largest Element in Unsorted Array
	--min heap
Kth smallest element in a row-wise and column-wise sorted 2D array
	--min heap
Median of Stream of Running Integers
	--sliding window
Connect n ropes with minimum cost

----------------------------------------------------------------------

private static int pivotIncreasing(int start, int end, int arr[]) {
    if(start > end || start == arr.length-1) {
        return -1;
    } else {
        int mid = start + (end-start)/2;
        if(arr[mid] > arr[mid+1]) {
            return mid;
        } else if(arr[start] > arr[mid]) {
            return pivotIncreasing(start, mid-1, arr);
        } else {
            return pivotIncreasing(mid+1, end, arr);
        }
    }
}

private static int pivotDecreasing(int start, int end, int arr[]) {
    if(start > end || start == arr.length-1) {
        return -1;
    } else {
        int mid = start + (end-start)/2;
        if(arr[mid] < arr[mid+1]) {
            return mid;
        } else if(arr[start] < arr[mid]) {
            return pivotDecreasing(start, mid-1, arr);
        } else {
            return pivotDecreasing(mid+1, end, arr);
        }
    }
}


-------------------

//Rearrange an array such that arr[i] = i
int place(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] == -1) {
			i++;
		} else {
			if(arr[i] != i) {
				int temp = arr[arr[i]];
				arr[arr[i]] = arr[i];
				arr[i] = temp;
			} else {
				i++;
			}
		}
	}
}

-------------------

//Move all negative numbers to beginning and positive to end
void moveNegativeToStart(int arr[]) {
	int i=-1;
	int j=0;
	while(j < arr.length) {
		if(arr[j] < 0) {
			i++;
			swap(arr, i, j);
		}
		j++;
	}
}

-------------------

//Rearrange an array such that �arr[j]� becomes �i� if �arr[i]� is �j�
void replace(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] != i) {
			replaceInternal(arr, i);
		} else {
			i++;
		}
	}
}

void replaceInternal(int arr[], int i) {
	if(arr[i] != i) {
		int j = arr[arr[i]];
		arr[i] = i;
		replaceInternal(arr, j);
	}
}

-------------------

//print longest increasing substring 
int longestIncreasingSubstring(int arr[]) {
	int max = 1;
	int maxEndingHere = 1;
	int maxStart = 0;
	int maxStartTemp = 0;
	int maxEnd = 0;
	for(int i=1; i<arr.length; i++) {
		if(arr[i] > arr[i-1]) {
			maxEndingHere++;
		} else {
			if(maxEndingHere > max) {
				max = maxEndingHere;
				maxEnd = i-1;
				maxStart = maxStartTemp;
			}
			maxEndingHere = 1;
			maxStartTemp = i;
		}
	}
	if(maxEndingHere > max) {
		max = maxEndingHere;
		maxEnd = arr.length-1;
		maxStart = maxStartTemp;
	}
	System.out.println(maxStart);
	System.out.println(maxEnd);
	return max;
}

-------------------

// longest increasing subsequence

LIS - lis including current index (memoized array)
MAX - max lis found till now (variable)

Arr :	10, 22, 9, 33, 21, 50, 41, 60, 80

LIS :	1	2	1	3	2	4	4	5	6
MAX :	1	2	2	3	3	4	4	5	6


int longestIncreasingSubsequence(int arr[]) {
	int max = 1;
	int LIS[] = new int[arr.length];
	for(int i=0; i<LIS.length; i++) {
		LIS[i] = 1;
	}
	for(int i=1; i<arr.length; i++) {
		for(int j=i-1; j>=0; j--) {
			if(arr[i] > arr[j]) {
				LIS[i] = LIS[j] + 1;
				if(LIS[i] > max) {
					max = LIS[i];
				}
			}
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subsequence
//this is based on longest increasing subsequence
int longestBitonicSubsequence(int arr[]) {
	int lis[] = new int[arr.length];
	int lds[] = new int[arr.length];
	for(int i=0; i<lis.length; i++) {
		lis[i] = 1;
	}
	for(int i=0; i<lds.length; i++) {
		lds[i] = 1;
	}
	for(int i=1; i<lis.length; i++) {
		for(int j=i-1; j>=0; j--) {
			if(arr[i] > arr[j]) {
				lis[i] = lis[j] + 1;
			}
		}
	}
	for(int i=n-2; i>=0; i--) {
		for(int j=i+1; j<arr.length; j++) {
			if(arr[i] > arr[j]) {
				lds[i] = lds[j] + 1;
			}
		}
	}
	int max = 0;
	for(int i=0; i<arr.length; i++) {
		if(lis[i] + lds[i] - 1 > max) {
			max = lis[i] + lds[i] - 1;
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subarray
//	time = O(n)
//	memory = O(n)
int longestBitonicSubarray(int arr[]) {
	int lis[] = new int[arr.length];
	int lds[] = new int[arr.length];
	for(int i=0; i<lis.length; i++) {
		lis[i] = 1;
	}
	for(int i=0; i<lds.length; i++) {
		lds[i] = 1;
	}
	for(int i=1; i<lis.length; i++) {
		if(arr[i] > arr[i-1]) {
			lis[i] = lis[i-1] + 1;
		}
	}
	for(int i=n-2; i>=0; i--) {
		if(arr[i] > arr[i+1]) {
			lds[i] = lds[i+1] + 1;
		}
	}
	int max = 0;
	for(int i=0; i<arr.length; i++) {
		if(lis[i] + lds[i] - 1 > max) {
			max = lis[i] + lds[i] - 1;
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subarray
//	time = O(n)
//	memory = O(1)
int longestBitonicSubarray(int arr[]) {
	int j=0;
	int n = arr.length;
	int start = 0;
	int startNext = 0;
	int max = 0;
	while(j < n) {
		while(j < n-1 && arr[j] <= arr[j+1]) {
			j++;
		}
		while(j < n-1 && arr[j] >= arr[j+1]) {
			if(j < n-1 && arr[j] > arr[j+1]) {
				startNext = j + 1;
			}
			j++;
		}
		if(j - start + 1 > max) {
			max = j - start + 1;
		}
		start = startNext;
	}
	return max;
}

-------------------

// print all subsequences of a string 

input : ABC
output : A B C AB AC BC ABC

ABC		->	BC	->	C

A			B		C
AB			BC
ABC			C
AC
B
BC
C



void printAllSubsequences(String arr) {
	List<List<Character>> list = getAllSubsequences(arr.toCharArray(), 0, arr.length-1);
	for(List<Character> characters : list) {
		System.out.println(characters);
	}
}

private List<List<Character>> getAllSubsequences(char arr[], int start, int end) {
	List<List<Character>> returnList = new LinkedList<>();
	List<Character> list = new LinkedList<>();
	list.add(arr[start]);
	returnList.add(list);
	if(end > start) {
		List<List<Character>> recursiveList = getAllSubsequences(arr, start+1, end);
		returnList.addAll(recursiveList);
		
		List<List<Character>> copiedRecursiveList = new new LinkedList<>(recursiveList);
		for(List temp : copiedRecursiveList) {
			temp.addFirst(arr[start]);
		}
		returnList.addAll(copiedRecursiveList);
	}
	return returnList;
}

-------------------

// sort stack using, pop() push() size() top() methods

void emptyStack(Stack stack) {
	
	if(stack.size() != 0) {
		int temp = stack.pop();
		emptyStack(stack);
		sortStack(stack, temp);
	}
}

void sortStack(Stack stack, int temp) {
	if(stack.size() != 0) {
		int top = stack.peek();
		if(top <= temp) {
			stack.push(temp);
		} else {
			stack.pop();
			sortStack(stack, temp);
			stack.push(top);
		}
	} else {
		stack.push(temp);
	}
}

-------------------

=> Segment Tree

input array : [1, 3, 5, 7, 9, 11]
segment tree array : [36, 9, 27, 4, 5, 16, 11, 1, 3, 0, 0, 7, 9, 0, 0]

class Node {
	int value;
	int leftLimit;
	int rightLimit;
	Node left;
	Node right;
}

// linked list based binary tree
int getSum(Node treeNode, int low, int high) {
	if(treeNode == null) {
		return 0;
	}
	if(treeNode.leftLimit >= low && treeNode.rightLimit <= high) {
		return treeNode.value;
	}
	if(treeNode.leftLimit > high || treeNode.rightLimit < low) {
		return 0;
	}
	return getSum(treeNode.left, low, high) + getSum(treeNode.right, low, high);
}

// array based binary tree
int getSum(int tree[], int low, int high) {
	//TODO :
}


Node createSegmentTree(int arr[], int start, int end) {
	if(end > start) {
		return null;
	}
	if(start == end) {
		//leaf node
		Node node = new Node(arr[start]);
		node.leftLimit = start;
		node.rightLimit = end;
		return node;
	}
	if(end = start + 1) {
		Node parentNode = new Node(arr[start] + arr[end]);
		parentNode.left = new Node(arr[start]);
		parentNode.right = new Node(arr[end]);
		parentNode.leftLimit = start;
		parentNode.rightLimit = end;
		return parentNode;
	}
	int mid = start + (end-start)/2;
	Node leftNode = createSegmentTree(arr, start, mid);
	Node rightNode = createSegmentTree(arr, mid+1, end);
	if(leftNode == null) {
		return rightNode;
	}
	if(rightNode == null) {
		return leftNode;
	}
	int sum = leftNode.value + rightNode.value;
	Node parentNode = new Node(sum);
	parentNode.left = leftNode;
	parentNode.right = rightNode;
	parentNode.leftLimit = start;
	parentNode.rightLimit = end;
	return parentNode;
}

-----------------------
