https://leetcode.com/problemset/all/?difficulty=Hard&topicSlugs=array
https://www.geeksforgeeks.org/array-data-structure/


=>sorting algo
->bubble
->selection
->insertion

find minimum and maximum element in an array (bubble, selection)

=>merge sort
merging two sorted arrays
merging two sorted arrays without using extra space
merging two sorted linked list
merging two sorted linked list without using extra space (create a new linked list in sorted order)
count number of inversions
iterative way of merge sort


=>quick sort
sort array of 0 and 1
sort array of 0 1 and 2
segregate numbers smaller and larger than x
Move all negative numbers to beginning and positive to end
iterative way of quick sort


=>Heap sort
build heap from array
merge k sorted arrays
sort nearly sorted array
Kth Smallest/Largest Element in Unsorted Array
Kth smallest element in a row-wise and column-wise sorted 2D array
convert min heap to max heap
place 1 farthest from 0 in an array of 0 and 1
Median of Stream of Running Integers
Connect n ropes with minimum cost


=>counting sort
lexicographicaly maximum string

a X b = LCM(a,b) X HCF(a,b)

HCF
-> rotation of an array using reversal
-> find common matching time for diff time intervals (fountain problem)

Segment tree
Interval tree


=>binary search
find pivot element in sorted and rotated array
sorted array with all elements having 2 occurence except 1 element, find that element
majority element in a sorted array



=> stack questions

check if Parenthesis are correct or not, [{{}}]({})
check if Parenthesis are correct or not, * can be used as any character
    valid -> ()()* , (())(* , * , *)(), (()) , (((*))(**
    invalid -> ())*()
reverse stack using recursion
sort stack using recursion
queue using stack
Design a stack with operations on middle element
stack with get min on constant time
Next Greater Element
The Stock Span Problem
Largest Rectangular Area in a Histogram
	-> use segment tree , time = O(N.logN)
	-> nearest min in left and nearest min in right
		Find the nearest smaller numbers on left side in an array
histogram with water
	-> max index of left and right


=> moore algorithm
Majority Element in an array
Online Majority Element In Subarray


=> array sum problem

Find all triplets with zero sum
Given an array A[] and a number x, check for pair in A[] with sum as x
Find a triplet that sum to a given value
Find a triplet in an array whose sum is closest to a given number
Maximum value of expression (arr[i] + arr[j] * arr[k]) formed from a valid Triplet
	such that arr[i] < arr[j] < arr[k] and i < j < k
	-> maintain 2 arrays of min number in left and max number in right
Find a triplet such that sum of two equals to third element
Find triplet with minimum sum

=> sum , diff problem, stock buy sell problem

max diff in an array arr, max of (arr[j] - arr[i]), j>i
Stock buy and sell problem
maximum profit by buying and selling a stock at most twice
maximum profit by buying and selling a stock at most k times
substring sum problem
substring sum problem without taking adjacent
max diff bw numbers without taking adjacent from left to right
given an array arr find the maximum j-i such that arrj arri


minimum broadcast range required by m towers to reach n houses
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters

Largest Sum Contiguous Subarray
Maximum Sum Increasing Subsequence
Longest increasing Subsequence


=======================

// merging two sorted arrays without using extra space
arr1 : {i1, i2... in} , arr2 : {j1, j2.. jn}
if(arr1[i] <= arr2[j]) {
    i++;
} else {
    swap(i, j);
    fix j in arr2 using insertion sort
    i++;
}

-----------------

// Find all triplets with zero sum
List<List<Integer>> threeSumToZero(int[] nums) {
	if(nums.length < 3) {
            return new ArrayList<>();
        }
	Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        for (int i=0; i<n-1; i++)
        {
            // initialize left and right
            int l = i + 1;
            int r = n - 1;
            int x = nums[i];
            while (l < r)
            {
                if (x + nums[l] + nums[r] == 0)
                {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[l]);
                    temp.add(nums[r]);
                    result.add(temp);

                    l++;
                    r--;
                } else if (x + nums[l] + nums[r] < 0) {
                    l++;
                } else {
                    r--;
                }
            }
        }
        return result;
}



// max diff in an array arr, max of (arr[j] - arr[i]), j>i

5 2 7 1 3 9
ans : 8

int maxDiff(int arr[]) {
	int minTillNow = arr[0];
	int maxDiff = 0;
	for(int i=1; i<arr.length; i++) {
		if(arr[i] - minTillNow > maxDiff) {
			maxDiff = arr[i] - minTillNow;
		}
		if(minTillNow > arr[i]) {
			minTillNow = arr[i];
		}
	}
	return maxDiff;
}



// maximum profit by buying and selling a stock at most twice

public int maxProfit(int[] prices) {
	final int n = prices.length;
	if(n < 2) {
	    return 0;
	}
	int maxDiff = 0;
	for(int i=0; i<n; i++) {
	    int maxDiff1 = maxDiff(prices, 0, i);
	    int maxDiff2 = maxDiff(prices, i+1, n-1);
	    maxDiff = Math.max(maxDiff, maxDiff1 + maxDiff2);
	}
	return maxDiff;
}

private int maxDiff(int arr[], int start, int end) {
	int length = end - start;
	if(length < 1) {
	    return 0;
	}
	int maxDiff = 0;
	int minTillNow = arr[start];
	for(int i=start+1; i<=end; i++) {
	    if(arr[i] - minTillNow > maxDiff) {
		maxDiff = arr[i] - minTillNow;
	    }
	    if(arr[i] < minTillNow) {
		minTillNow = arr[i];
	    }
	}
	return maxDiff;
}

==========================

// lexicographicaly maximum string

https://leetcode.com/problems/remove-duplicate-letters/
https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/
https://leetcode.com/problems/last-substring-in-lexicographical-order/submissions/



last substring of a string in lexicographical order
-> abab
-> bab

-> cacacb
-> cb

https://www.geeksforgeeks.org/lexicographically-smallest-string-formed-by-removing-duplicates/?ref=rp

===============================

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/submissions/
// Find Minimum in Rotated Sorted Array

class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;
        if(n == 1) {
            return nums[0];
        }
        if(nums[0] < nums[n-1]) {
            return nums[0];
        }
        return recur(nums, 0, n-1);
    }

    private int recur(int arr[], int start, int end) {
        System.out.println("start = "+start + ", end = "+end);
        if(start <= end) {
            int mid = start + (end-start) / 2;
            int prev = mid-1;
            int next = mid+1;
            if(prev < 0) {
                prev = arr.length-1;
            }
            if(next > arr.length-1) {
                next = 0;
            }
            if(arr[mid] < arr[next] &&  arr[mid] < arr[prev]) {
                return arr[mid];
            } else if(arr[mid] >= arr[0] ) {
                return recur(arr, mid+1, end);
            } else {
                return recur(arr, start, mid-1);
            }
        } else {
            return -1;
        }
    }
}


// Search in Rotated Sorted Array

// Find Minimum in Rotated Sorted Array with duplicates
public int findMin(int[] nums) {
	int n = nums.length;
	if(n == 1) {
	    return nums[0];
	}
	if(nums[0] < nums[n-1]) {
	    return nums[0];
	}
	int start = 0;
	int end = n-1;
	while(end > start) {
	    int mid = start + (end-start)/2;
	    if(nums[mid] == nums[end]) {
		end--;
	    } else if(nums[mid] > nums[end]) {
		start = mid+1;
	    } else {
		end = mid;
	    }
	}
	return nums[end];
}

============


Segment tree using array implementation

int n = arr.length;
int x = (int) Math.ceil( Math.log(n) / Math.log(2) );
int y = (int) Math.pow(2, x);
int treeSize = 2*y - 1;
int tree[] = new int[treeSize];

// divide arr into 2 subarrays [0..(x/2)-1] and [x/2 .. n-1]
// each subarray will return a subresult
// 2 subresults are applied to a function and returned as result



// online majority check using Segment tree, moore algo can also be applied
class MajorityChecker {

    private int arr[];
    private STNode root;

    public MajorityChecker(int[] arr) {
        this.arr = arr;
        root = createST(0, arr.length-1);
    }

    public int query(int left, int right, int threshold) {

        Map<Integer,Integer> map = query(root, left, right);
        for(Integer key : map.keySet()) {
            if(map.get(key).intValue() >= threshold) {
               return key;
            }
        }
        return -1;
    }

    private Map<Integer,Integer> query(STNode node, int low, int high) {
        if(node == null) {
            return new HashMap<>();
        }
        if(node.leftIndex >= low && node.rightIndex <= high) {
            return node.map;
        } else if(node.rightIndex < low || node.leftIndex > high) {
            return new HashMap<>();
        } else {
            Map<Integer,Integer> map1 = query(node.left, low, high);
            Map<Integer,Integer> map2 = query(node.right, low, high);
            return mergeMap(map1, map2);
        }
    }

    class STNode {
        int leftIndex;
        int rightIndex;
        STNode left;
        STNode right;
        Map<Integer,Integer> map = new HashMap<>();

        STNode() {

        }

        STNode(int leftIndex, int rightIndex) {
            this.leftIndex = leftIndex;
            this.rightIndex = rightIndex;
        }
    }

    private STNode createST(int start, int end) {
        if(end < start) {
            return null;
        }
        if(start == end) {
            STNode stNode = new STNode(start, end);
            populateMap(stNode.map, arr[start]);
            return stNode;
        }
        if(end == start + 1) {
            STNode stNode = new STNode(start, end);
            populateMap(stNode.map, arr[start]);
            populateMap(stNode.map, arr[end]);

            STNode leftStNode = new STNode(start, start);
            populateMap(leftStNode.map, arr[start]);
            stNode.left = leftStNode;

            STNode rightStNode = new STNode(end, end);
            populateMap(rightStNode.map, arr[end]);
            stNode.right = rightStNode;

            return stNode;
        }
        int mid = start + (end-start)/2;
        STNode node1 = createST(start, mid);
        STNode node2 = createST(mid+1, end);
        if(node1 == null) {
            return node2;
        }
        if(node2 == null) {
            return node1;
        }
        STNode rootStNode = new STNode(start, end);
        rootStNode.map = mergeMap(node1.map, node2.map);
        rootStNode.left = node1;
        rootStNode.right = node2;
        return rootStNode;
    }

    private void populateMap(Map<Integer,Integer> map, int key) {
        Integer value = map.get(key);
        if(value == null) {
            map.put(key, 1);
        } else {
            map.put(key, value+1);
        }
    }

    private Map<Integer,Integer> mergeMap(Map<Integer,Integer> map1, Map<Integer,Integer> map2) {

        Map<Integer,Integer> mainMap = new HashMap<>();
        Set<Integer> set = new HashSet(map1.keySet());
        set.addAll(map2.keySet());
        for(Integer key : set) {
            Integer value1 = map1.get(key);
            if(value1 == null) {
                value1 = 0;
            }
            Integer value2 = map2.get(key);
            if(value2 == null) {
                value2 = 0;
            }
            mainMap.put(key, value1 + value2);
        }
        return mainMap;
    }
}




==================================================

=> Array Rotation
rotate array by d elements
Lexicographically minimum string rotation
Rotate Matrix Elements
Print a given matrix in spiral form
Inplace rotate square matrix by 90 degrees
Check if all rows of a matrix are circular rotations of each other
Minimum rotations required to get the same string
Check if strings are rotations of each other or not
maximum sum in an array without adjacent elements
Count minimum number of fountains to be activated to cover the entire garden
-> Input : arr1 = {2, 3, 10, 6, 4, 8, 1}
   Output : 8
   max diff bw two elements
   larger element appears after smaller element


--Print all subarrays with 0 sum
max sum subarray
max sum subarray without adjacent
max diff in an array of integers, such that A[j] > A[i] and j>i

Find subarray with given sum (Nonnegative Numbers)
Find subarray with given sum (array having negative numbers)
print all permutations of a given string
print all subsequences of a string


=> Array rearrangement
Rearrange an array such that arr[i] = i
Move all negative numbers to beginning and positive to end
Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i
Convert array into Zig-Zag fashion
Rearrange array in alternating positive & negative items with O(1) extra space  -> quick sort logic
Rearrange array such that even positioned are greater than odd
Rearrange an array such that �arr[j]� becomes �i� if �arr[i]� is �j�
Arrange given numbers to form the biggest number
Longest Bitonic Subsequence  -> DP
Longest Bitonic SubArray	-> O(n) time, O(1) space
Maximum Sum Increasing Subsequence (positive numbers)
	->similar to longest increasing subsequence

--Minimum swaps required to bring all elements less than or equal to k together
--Find a sorted subsequence of size 3 in linear time
--Largest subarray with equal number of 0s and 1s



===========================

private static int pivotIncreasing(int start, int end, int arr[]) {
    if(start > end || start == arr.length-1) {
        return -1;
    } else {
        int mid = start + (end-start)/2;
        if(arr[mid] > arr[mid+1]) {
            return mid;
        } else if(arr[start] > arr[mid]) {
            return pivotIncreasing(start, mid-1, arr);
        } else {
            return pivotIncreasing(mid+1, end, arr);
        }
    }
}

private static int pivotDecreasing(int start, int end, int arr[]) {
    if(start > end || start == arr.length-1) {
        return -1;
    } else {
        int mid = start + (end-start)/2;
        if(arr[mid] < arr[mid+1]) {
            return mid;
        } else if(arr[start] < arr[mid]) {
            return pivotDecreasing(start, mid-1, arr);
        } else {
            return pivotDecreasing(mid+1, end, arr);
        }
    }
}


-------------------

//Rearrange an array such that arr[i] = i
int place(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] == -1) {
			i++;
		} else {
			if(arr[i] != i) {
				int temp = arr[arr[i]];
				arr[arr[i]] = arr[i];
				arr[i] = temp;
			} else {
				i++;
			}
		}
	}
}

-------------------

//Move all negative numbers to beginning and positive to end
void moveNegativeToStart(int arr[]) {
	int i=-1;
	int j=0;
	while(j < arr.length) {
		if(arr[j] < 0) {
			i++;
			swap(arr, i, j);
		}
		j++;
	}
}

-------------------

//Rearrange an array such that �arr[j]� becomes �i� if �arr[i]� is �j�
void replace(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] != i) {
			replaceInternal(arr, i);
		} else {
			i++;
		}
	}
}

void replaceInternal(int arr[], int i) {
	if(arr[i] != i) {
		int j = arr[arr[i]];
		arr[i] = i;
		replaceInternal(arr, j);
	}
}

-------------------

//print longest increasing substring
int longestIncreasingSubstring(int arr[]) {
	int max = 1;
	int maxEndingHere = 1;
	int maxStart = 0;
	int maxStartTemp = 0;
	int maxEnd = 0;
	for(int i=1; i<arr.length; i++) {
		if(arr[i] > arr[i-1]) {
			maxEndingHere++;
		} else {
			if(maxEndingHere > max) {
				max = maxEndingHere;
				maxEnd = i-1;
				maxStart = maxStartTemp;
			}
			maxEndingHere = 1;
			maxStartTemp = i;
		}
	}
	if(maxEndingHere > max) {
		max = maxEndingHere;
		maxEnd = arr.length-1;
		maxStart = maxStartTemp;
	}
	System.out.println(maxStart);
	System.out.println(maxEnd);
	return max;
}

-------------------

// longest increasing subsequence

LIS - lis including current index (memoized array)
MAX - max lis found till now (variable)

Arr :	10, 22, 9, 33, 21, 50, 41, 60, 80

LIS :	1	2	1	3	2	4	4	5	6
MAX :	1	2	2	3	3	4	4	5	6


int longestIncreasingSubsequence(int arr[]) {
	int max = 1;
	int LIS[] = new int[arr.length];
	for(int i=0; i<LIS.length; i++) {
		LIS[i] = 1;
	}
	for(int i=1; i<arr.length; i++) {
		for(int j=i-1; j>=0; j--) {
			if(arr[i] > arr[j]) {
				LIS[i] = LIS[j] + 1;
				if(LIS[i] > max) {
					max = LIS[i];
				}
			}
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subsequence
//this is based on longest increasing subsequence
int longestBitonicSubsequence(int arr[]) {
	int lis[] = new int[arr.length];
	int lds[] = new int[arr.length];
	for(int i=0; i<lis.length; i++) {
		lis[i] = 1;
	}
	for(int i=0; i<lds.length; i++) {
		lds[i] = 1;
	}
	for(int i=1; i<lis.length; i++) {
		for(int j=i-1; j>=0; j--) {
			if(arr[i] > arr[j]) {
				lis[i] = lis[j] + 1;
			}
		}
	}
	for(int i=n-2; i>=0; i--) {
		for(int j=i+1; j<arr.length; j++) {
			if(arr[i] > arr[j]) {
				lds[i] = lds[j] + 1;
			}
		}
	}
	int max = 0;
	for(int i=0; i<arr.length; i++) {
		if(lis[i] + lds[i] - 1 > max) {
			max = lis[i] + lds[i] - 1;
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subarray
//	time = O(n)
//	memory = O(n)
int longestBitonicSubarray(int arr[]) {
	int lis[] = new int[arr.length];
	int lds[] = new int[arr.length];
	for(int i=0; i<lis.length; i++) {
		lis[i] = 1;
	}
	for(int i=0; i<lds.length; i++) {
		lds[i] = 1;
	}
	for(int i=1; i<lis.length; i++) {
		if(arr[i] > arr[i-1]) {
			lis[i] = lis[i-1] + 1;
		}
	}
	for(int i=n-2; i>=0; i--) {
		if(arr[i] > arr[i+1]) {
			lds[i] = lds[i+1] + 1;
		}
	}
	int max = 0;
	for(int i=0; i<arr.length; i++) {
		if(lis[i] + lds[i] - 1 > max) {
			max = lis[i] + lds[i] - 1;
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subarray
//	time = O(n)
//	memory = O(1)
int longestBitonicSubarray(int arr[]) {
	int j=0;
	int n = arr.length;
	int start = 0;
	int startNext = 0;
	int max = 0;
	while(j < n) {
		while(j < n-1 && arr[j] <= arr[j+1]) {
			j++;
		}
		while(j < n-1 && arr[j] >= arr[j+1]) {
			if(j < n-1 && arr[j] > arr[j+1]) {
				startNext = j + 1;
			}
			j++;
		}
		if(j - start + 1 > max) {
			max = j - start + 1;
		}
		start = startNext;
	}
	return max;
}

-------------------

// print all subsequences of a string

input : ABC
output : A B C AB AC BC ABC

ABC		->	BC	->	C

A			B		C
AB			BC
ABC			C
AC
B
BC
C



void printAllSubsequences(String arr) {
	List<List<Character>> list = getAllSubsequences(arr.toCharArray(), 0, arr.length-1);
	for(List<Character> characters : list) {
		System.out.println(characters);
	}
}

private List<List<Character>> getAllSubsequences(char arr[], int start, int end) {
	List<List<Character>> returnList = new LinkedList<>();
	List<Character> list = new LinkedList<>();
	list.add(arr[start]);
	returnList.add(list);
	if(end > start) {
		List<List<Character>> recursiveList = getAllSubsequences(arr, start+1, end);
		returnList.addAll(recursiveList);

		List<List<Character>> copiedRecursiveList = new new LinkedList<>(recursiveList);
		for(List temp : copiedRecursiveList) {
			temp.addFirst(arr[start]);
		}
		returnList.addAll(copiedRecursiveList);
	}
	return returnList;
}

-------------------

// sort stack using, pop() push() size() top() methods

void emptyStack(Stack stack) {

	if(stack.size() != 0) {
		int temp = stack.pop();
		emptyStack(stack);
		sortStack(stack, temp);
	}
}

void sortStack(Stack stack, int temp) {
	if(stack.size() != 0) {
		int top = stack.peek();
		if(top <= temp) {
			stack.push(temp);
		} else {
			stack.pop();
			sortStack(stack, temp);
			stack.push(top);
		}
	} else {
		stack.push(temp);
	}
}

-------------------

=> Segment Tree

input array : [1, 3, 5, 7, 9, 11]
segment tree array : [36, 9, 27, 4, 5, 16, 11, 1, 3, 0, 0, 7, 9, 0, 0]

class Node {
	int value;
	int leftLimit;
	int rightLimit;
	Node left;
	Node right;
}

// linked list based binary tree
int getSum(Node treeNode, int low, int high) {
	if(treeNode == null) {
		return 0;
	}
	if(treeNode.leftLimit >= low && treeNode.rightLimit <= high) {
		return treeNode.value;
	}
	if(treeNode.leftLimit > high || treeNode.rightLimit < low) {
		return 0;
	}
	return getSum(treeNode.left, low, high) + getSum(treeNode.right, low, high);
}

// array based binary tree
int getSum(int tree[], int low, int high) {
	//TODO :
}


Node createSegmentTree(int arr[], int start, int end) {
	if(end > start) {
		return null;
	}
	if(start == end) {
		//leaf node
		Node node = new Node(arr[start]);
		node.leftLimit = start;
		node.rightLimit = end;
		return node;
	}
	if(end = start + 1) {
		Node parentNode = new Node(arr[start] + arr[end]);
		parentNode.left = new Node(arr[start]);
		parentNode.right = new Node(arr[end]);
		parentNode.leftLimit = start;
		parentNode.rightLimit = end;
		return parentNode;
	}
	int mid = start + (end-start)/2;
	Node leftNode = createSegmentTree(arr, start, mid);
	Node rightNode = createSegmentTree(arr, mid+1, end);
	if(leftNode == null) {
		return rightNode;
	}
	if(rightNode == null) {
		return leftNode;
	}
	int sum = leftNode.value + rightNode.value;
	Node parentNode = new Node(sum);
	parentNode.left = leftNode;
	parentNode.right = rightNode;
	parentNode.leftLimit = start;
	parentNode.rightLimit = end;
	return parentNode;
}


============================
