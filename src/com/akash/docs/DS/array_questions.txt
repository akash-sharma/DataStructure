helping DS in array questions
        (Stack, Queue, Map, Set, Heap, BST, segment tree, interval tree, bits, sorting algo, 2D-array)

DS implementation in java

queue -> LinkedList
stack -> Stack
heap -> PriorityQueue
map -> HashMap
set -> HashSet
TreeMap -> BST (RB tree)
TreeSet -> BST (RB tree)


Queue<Integer> queue = new LinkedList<>(); // poll(), add()
Queue<Integer> minHeap = new PriorityQueue<Integer>(); // poll(), add()
Queue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());

===================================================

https://leetcode.com/problemset/all/?difficulty=Hard&topicSlugs=array
https://www.geeksforgeeks.org/array-data-structure/


=>sorting algo
->bubble
->selection
->insertion

find minimum and maximum element in an array (bubble, selection)

=>merge sort
merging two sorted arrays
merging two sorted arrays without using extra space
merging two sorted linked list
merging two sorted linked list without using extra space (create a new linked list in sorted order)
count number of inversions
iterative way of merge sort


=>quick sort
sort array of 0 and 1
sort array of 0 1 and 2
segregate numbers smaller and larger than x
Move all negative numbers to beginning and positive to end
iterative way of quick sort


=>Heap sort
build heap from array
merge k sorted arrays
sort nearly sorted array
Kth Smallest/Largest Element in Unsorted Array
printing k largest elements in an array
Kth smallest element in a row-wise and column-wise sorted 2D array
    -> merge k sorted arrays
count negative numbers in a row-wise and column-wise sorted 2D array
    -> binary search solution
place 1 farthest from 0 in an array of 0 and 1
Median of Stream of Running Integers
Connect n ropes with minimum cost
find minimum element in max heap


=>counting sort
lexicographicaly maximum string
lexicographicaly minimum string without duplicate : cbacdcbc -> abcd
Lexicographically smallest string formed by removing duplicates : cbacdcbc -> acdb
    ->lexicographicaly minimum string without duplicate with maintaining order
last substring of a string in lexicographical order : abab -> bab , cacacb -> cb


a X b = LCM(a,b) X HCF(a,b)

HCF
-> rotation of an array using reversal
-> find common matching time for diff time intervals (fountain problem)


Trie


=>binary search
find pivot element in sorted and rotated array
find pivot element in sorted and rotated array with duplicates
sorted array with all elements having 2 occurence except 1 element, find that element
search an element in a row-wise and column-wise sorted 2D array
majority element in a sorted array
Find first and last positions of an element in a sorted array

Capacity To Ship Packages Within D Days
Minimum Number of Days to Make m Bouquets
Find the Smallest Divisor Given a Threshold
    https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
Koko Eating Bananas
    https://leetcode.com/problems/koko-eating-bananas/
Split Array Largest Sum
    https://leetcode.com/problems/split-array-largest-sum/


=> stack questions

check if Parenthesis are correct or not, [{{}}]({})
count minimum number of reversals to make an parenthesis expression as balanced
check if Parenthesis are correct or not, * can be used as any character
    valid -> ()()* , (())(* , * , *)(), (()) , (((*))(**
    invalid -> ())*()
        -> reversal problem logic
Evaluation of Postfix Expression : 2 3 1 * + 9 -  , 100 200 + 2 / 5 * 7 +
postfix to infix expression
infix to postfix Expression : a+b*(c^d-e)^(f+g*h)-i
sort a stack using stack
sort stack using recursion
implement two stack in one array
    -> maintain stacks in opposite corners
Reverse First K elements of Queue
Queue reversal
reverse stack using recursion
queue using stack
Design a stack with operations on middle element
stack with get min in constant time and memory
Largest Rectangular Area in a Histogram
histogram with water
	-> max/min index of left and right
* Celebrity problem


=> moore algorithm
Majority Element in an array
Online Majority Element In Subarray


=> array sum problem

Find all triplets with zero sum
Given an array A[] and a number x, check for pair in A[] with sum as x
Find a triplet that sum to a given value
Find a triplet in an array whose sum is closest to a given number
Maximum value of expression (arr[i] + arr[j] * arr[k]) formed from a valid Triplet
	such that arr[i] < arr[j] < arr[k] and i < j < k
	-> maintain 2 arrays of min number in left and max number in right
Find a triplet such that sum of two equals to third element
Find triplet with minimum sum

=> sum , diff problem, stock buy sell problem

max diff in an array arr, max of (arr[j] - arr[i]), j>i
Stock buy and sell problem
maximum profit by buying and selling a stock at most twice
maximum profit by buying and selling a stock at most k times
max diff bw numbers without taking adjacent from left to right
given an array arr find the maximum j-i such that arrj arri


minimum broadcast range required by m towers to reach n houses
Minimum number of towers required such that every house is in the range of at least one tower
Check if given point lies in range of any of the given towers
Minimum number of moves required to reach the destination by the king in a chess board


Largest Sum Contiguous Subarray
maximum sum subsequence when no two elements are adjacent
Find maximum possible stolen value from houses

=> Prefix Sum Array
check if there is a subarray with 0 sum
Equilibrium index of an array
Count of seats booked on each of the given N flights

=> Window Sliding Technique
Given an array and an integer k, calculate max sum of subarray of k size
Given an array and an integer k, calculate max subarray size whose sum is less than or equal to k

https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/


longest increasing substring
longest increasing subsequence
Maximum Sum Increasing Subsequence

Longest Bitonic Subsequence
Longest Bitonic Subarray

=> interval problems :
check if there is any conflict in intervals
Given train arrival and departure time, find minimum number of platforms required
Given n appointments, find all conflicting appointments
Find the point where maximum intervals overlap

=> backtracking
=> permutation of String
Kth permutation of String - ABCD
print all permutation of String - ABCD
print all permutation of String with repeated characters - ABCDAC
find all subsets with given sum in an array with duplicates

Check if one String contains permutation of another String
    https://leetcode.com/problems/permutation-in-string/
print all permutation of a String in uppercase and lowercase
    https://leetcode.com/problems/letter-case-permutation/


* find all peak elements in an array

(1) Given a string, find the count of all substrings of a string having atmost 3 unique characters
(2) Give a matrix of n rows and m columns of 0’s and 1’s.
    In each row, the first few cells have a value 0 and the remaining all have value 1.
    The problem is to find the minimum index of the column which contains a value 1
(3) Given a grid . Find minimum moves to go from position  (0,0) to (n-1,n-1).
    But, the grid will have some obstacles and we can only go through at most k obstacles.
    Free position will be marked 0 and obstacle will be denoted by 1

minimum cost jump, forward = 2, backward 1


Max subarray sum
Max subarray sum with start and end
Maximum product subarray
Given non-negative numbers and a target integer k, check if any subarray of size at least 2 has sum multiple of k
Max sum subarray with one deletion

=======================

// merging two sorted arrays without using extra space
arr1 : {i1, i2... in} , arr2 : {j1, j2.. jn}
if(arr1[i] <= arr2[j]) {
    i++;
} else {
    swap(i, j);
    fix j in arr2 using insertion sort
    i++;
}

----------------

// sort array of 0 1 and 2

int low = 0;
int high = arr.length - 1;

int i = 0;
for(i <= high) {
	if(arr[i] == 0) {
		swap(arr, low, i);
		low++;
		i++;
	} else if(arr[i] == 1) {
		i++;
	} else {
		swap(arr, i, high);
		high--;
	}
}

----------------

// build heap from array
void createHeap(arr) {
    for(int i=n/2; i>=0 ; i++) {
        heapify(arr, i);
    }
}

// min heap
void heapify(arr, i) {
    int n = arr.length;
    int left = 2*i + 1;
    int right = 2*i + 2;
    int smaller = i;
    if(arr[smaller] > arr[left] && left < n) {
        smaller = left;
    }
    if(arr[smaller] > arr[right] && right < n) {
        smaller = right;
    }
    if(smaller != i) {
        swap(arr, i, smaller);
        heapify(arr, smaller);
    }
}

----------------

// merge k sorted arrays

create min heap of 1st element of each array
repeat until min heap is empty
    pull min and heapify
    add element from that array whose element was pulled from heap previously and heapify
    if that array is empty then do nothing

complexity
time : O(NK(logK))
memory : O(k)

// java code for min heap
class MinHeapNode implements Comparable<MinHeapNode> {
    int value;
    int index;
    int rowIndex;

    @Override
    public int compareTo(MinHeapNode ob) {
        Integer current = new Integer(this.value);
        Integer compare = new Integer(ob.value);
        return current.compareTo(compare);
    }
}

Queue<MinHeapNode> minHeap = new PriorityQueue<>();

-----------------

// sort nearly sorted array
// almost sorted array with each element is at most k away from its target position

create min heap of k+1 size
pull min from heap and heapify
add another element from array to heap and heapify

-----------------

// kth smallest element
O(n + kLogn)
-> create a min heap of size n
-> poll elements k times from min heap

O(k + (n-k)*Logk)
-> create a max heap of size k [0..k-1]
-> now iterate in array from [k.. n-1]
	-> if array index is less than top of heap
		then put array index to top of heap and heapify
	-> else do nothing
-> top of heap is kth smallest element

-----------------

// Median of Stream of Running Integers

hint : minHeap will store larger numbers than median
       maxHeap will store smaller numbers than median

if(maxHeap.size() > minHeap.size()) {
	if(element < median) {
		temp = maxHeap.poll();
		minHeap.add(temp);
		maxHeap.add(element);
	} else {
		minHeap.add(element);
	}
	median = (minHeap.peek() + maxheap.peek()) / 2;
}
else if(maxHeap.size() < minHeap.size()) {
	if(element > median) {
		temp = minHeap.poll();
		maxHeap.add(temp);
		minHeap.add(element);
	} else {
		maxHeap.add(element);
	}
	median = (minHeap.peek() + maxheap.peek()) / 2;
}
else {		// both size equal
	if(element < median) {
		maxHeap.add(element);
		median = maxHeap.peek();
	} else {
		minHeap.add(element);
		median = minHeap.peek();
	}
}

-----------------

// search an element in a row-wise and column-wise sorted 2D array

start searching from top right corner
if match found then return
else if current element is smaller, then move down
else move left

time complexity : O(n)

-------------------

// sorted array with all elements having 2 occurence except 1 element, find that element

if mid is even
    if arr[mid-1] == arr[mid] then move right
    else move left
else
     if arr[mid-1] == arr[mid] then move left
     else move right

------------------

// majority element in a sorted array
// Find first and last positions of an element in a sorted array

public int[] searchRange(int[] nums, int target) {
    int n = nums.length;
    int firstIndex = searchFirst(nums, 0, n-1, target);
    if(firstIndex == -1) {
        return new int[]{-1, -1};
    }
    int lastIndex = searchLast(nums, firstIndex, n-1, target);
    return new int[]{firstIndex, lastIndex};
}

private int searchFirst(int nums[], int start, int end, int target) {
    if(end < start) {
        return -1;
    }
    int mid = start + (end-start)/2;
    if(nums[mid] == target) {
        if(mid == 0 || nums[mid] > nums[mid-1]) {
            return mid;
        } else {
            return searchFirst(nums, start, mid-1, target);
        }
    } else {
        if(nums[mid] > target) {
            return searchFirst(nums, start, mid-1, target);
        } else {
            return searchFirst(nums, mid+1, end, target);
        }
    }
}

private int searchLast(int nums[], int start, int end, int target) {
    int n = nums.length;
    if(end < start) {
        return -1;
    }
    int mid = start + (end-start)/2;
    if(nums[mid] == target) {
        if(mid == n-1 || nums[mid] < nums[mid+1]) {
            return mid;
        } else {
            return searchLast(nums, mid+1, end, target);
        }
    } else {
        if(nums[mid] > target) {
            return searchLast(nums, start, mid-1, target);
        } else {
            return searchLast(nums, mid+1, end, target);
        }
    }
}

------------------

// Capacity To Ship Packages Within D Days
https://www.youtube.com/watch?v=x3UclQq_EVk

find least weight capacity of the ship that allow weights to be shipped within D days.
// find least sum subarray, when array is divided in D or less subarrays

integer array = weights[]
integer as number of days = D

1 <= D <= weights.length <= 50000
1 <= weights[i] <= 500

int capacityToShip(int weights[], int D) {
    int minCapacity = max(weights)
    int maxCapacity = sigma(weights)

    for(int capacity = minCapacity; capacity <= maxCapacity; capacity++) {
        if(canBeTransferred(capacity, D, weights)) {
            return capacity;
        }
    }
}

boolean canBeTransferred(int capacity, int D, int[] weights) {
	int sum = 0;
	int days = 1;
	for(int weight : weights) {
		if(sum + weight <= capacity) {
			sum = sum + weight;
		} else {
			days++;
			sum = weight;
		}
	}
	return days < D;
}

time complexity = O(n * sum(weights))

// binary search approach
int capacityToShip(int weights[], int D) {
    int minCapacity = max(weights)
    int maxCapacity = sigma(weights)

    while(minCapacity < maxCapacity) {
        int mid = minCapacity + (maxCapacity-minCapacity)/2;
        if(canBeTransferred(mid, D, weights)) {
            maxCapacity = mid;
        } else {
            minCapacity = mid + 1;
        }
    }
    return minCapacity;
}

time complexity = O(n * log(sum(weights)))

------------------

// Minimum Number of Days to Make m Bouquets
Given an integer array bloomDay, an integer m and an integer k
We need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.
Return the minimum number of days to make m Bouquets

public int minDays(int[] bloomDay, int m, int k) {
    int n = bloomDay.length;
    if(m * k > n) {
        return -1;
    }
    int min = bloomDay[0];
    int max = bloomDay[0];
    for(int i=1; i<n; i++) {
        min = Math.min(min, bloomDay[i]);
        max = Math.max(max, bloomDay[i]);
    }
    while(min < max) {
        int mid = min + (max-min)/2;
        if(isPossible(bloomDay, m, k, mid)) {
            max = mid;
        } else {
            min = mid + 1;
        }
    }
    return min;
}

private boolean isPossible(int[] bloomDay, int m, int k, int dayCount) {

    int bouquetCount = 0;
    int lastNonBouquetIndex = -1;
    for(int index = 0; index < bloomDay.length; index++) {
        if(dayCount - bloomDay[index] >= 0) {
            if(index - lastNonBouquetIndex == k) {
                bouquetCount++;
                if(bouquetCount == m) {
                    return true;
                }
                lastNonBouquetIndex = index;
            }
        } else {
            lastNonBouquetIndex = index;
        }
    }
    return false;
}

time = O(n * log(n))

------------------

// check if Parenthesis are correct or not
approach 1 => using a stack , time = O(N), memory = O(N)

approach 2 => using 2 variables as open
when open found then open++
when close found then open--
if open==0 then Parenthesis are correct
time = O(N), memory = O(1)

-----------------------------

// count minimum number of reversals to make an parenthesis expression as balanced

logic : count number of unbalanced parenthesis, result = ceil(m/2) + ceil(n/2)
m : count of '}'
n : count of '{'

time : O(n)
memory : O(1)

start from index 0 to n-1
if opened parenthesis found
    open++
if closed parenthesis found
    if(open > 0)
        open--;
    else
        closed++;
return Math.ceil(open/2) + Math.ceil(closed/2);

-----------------------------

// Evaluation of Postfix Expression
// postfix to infix expression

if number found then push into stack
if operator found then pop two elements from stack and push result in stack

------------------------

// infix to postfix Expression
-> initialize postfix result and stack
-> if operand found push to result
-> if '(' found push to stack
-> if ')' found then pop all operators from stack and push to result until '(' found
-> if operator is found then
    -> if a higher(or equal) priority operator than current operator, is found on stack top
        then pop stack top and move it to result
    -> do above step until a lower priority operator is found
    -> push operator to stack
-> if expression is over and stack is non-empty
    then pop every element from stack and push to result

priority of operators :
^
*, /
+, -

------------------------

Largest Rectangular Area in a Histogram
	-> nearest min in left and nearest min in right
	    (nearest min in left -- from left to right)
	    (nearest min in right -- from right to left)

------------------------

// Design a stack with operations on middle element
use doubly linked list

------------------------

// stack with get min in constant time and memory

push() {
	if stack is empty {
		stack.push(element);
		min = element
	}
	else
		if (element > min) {
			stack.push(element);
		}
		else {
			temp = 2 * element - min;
			stack.push(temp);
			min = element;
		}
}

popMin() {
	if stack is empty {
		return null
	}
	else {
		top = stack.pop();
		if(top < min) {
			minTemp = min;
			min = 2 * min - top;
			return minTemp;
		}
		else {
			return top;
		}
	}
}

getMin() {
	return min;
}

peek() {
	top = stack.peek();
	if(top < min) {
		return min;
	}
	else {
		return top;
	}
}

------------------------

// Find all triplets with zero sum
List<List<Integer>> threeSumToZero(int[] nums) {
	if(nums.length < 3) {
            return new ArrayList<>();
        }
	Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        for (int i=0; i<n-1; i++)
        {
            // initialize left and right
            int l = i + 1;
            int r = n - 1;
            int x = nums[i];
            while (l < r)
            {
                if (x + nums[l] + nums[r] == 0)
                {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[l]);
                    temp.add(nums[r]);
                    result.add(temp);

                    l++;
                    r--;
                } else if (x + nums[l] + nums[r] < 0) {
                    l++;
                } else {
                    r--;
                }
            }
        }
        return result;
}



// max diff in an array arr, max of (arr[j] - arr[i]), j>i

5 2 7 1 3 9
ans : 8

int maxDiff(int arr[]) {
	int minTillNow = arr[0];
	int maxDiff = 0;
	for(int i=1; i<arr.length; i++) {
		if(arr[i] - minTillNow > maxDiff) {
			maxDiff = arr[i] - minTillNow;
		}
		if(minTillNow > arr[i]) {
			minTillNow = arr[i];
		}
	}
	return maxDiff;
}



// maximum profit by buying and selling a stock at most twice

public int maxProfit(int[] prices) {
	final int n = prices.length;
	if(n < 2) {
	    return 0;
	}
	int maxDiff = 0;
	for(int i=0; i<n; i++) {
	    int maxDiff1 = maxDiff(prices, 0, i);
	    int maxDiff2 = maxDiff(prices, i+1, n-1);
	    maxDiff = Math.max(maxDiff, maxDiff1 + maxDiff2);
	}
	return maxDiff;
}

private int maxDiff(int arr[], int start, int end) {
	int length = end - start;
	if(length < 1) {
	    return 0;
	}
	int maxDiff = 0;
	int minTillNow = arr[start];
	for(int i=start+1; i<=end; i++) {
	    if(arr[i] - minTillNow > maxDiff) {
		maxDiff = arr[i] - minTillNow;
	    }
	    if(arr[i] < minTillNow) {
		minTillNow = arr[i];
	    }
	}
	return maxDiff;
}

===============================

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/submissions/
// find pivot element in sorted and rotated array
// Find Minimum in Rotated Sorted Array

class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;
        if(n == 1) {
            return nums[0];
        }
        if(nums[0] < nums[n-1]) {
            return nums[0];
        }
        return recur(nums, 0, n-1);
    }

    private int recur(int arr[], int start, int end) {
        System.out.println("start = "+start + ", end = "+end);
        if(start <= end) {
            int mid = start + (end-start) / 2;
            int prev = mid-1;
            int next = mid+1;
            if(prev < 0) {
                prev = arr.length-1;
            }
            if(next > arr.length-1) {
                next = 0;
            }
            if(arr[mid] < arr[next] &&  arr[mid] < arr[prev]) {
                return arr[mid];
            } else if(arr[mid] >= arr[0] ) {
                return recur(arr, mid+1, end);
            } else {
                return recur(arr, start, mid-1);
            }
        } else {
            return -1;
        }
    }
}


// Search in Rotated Sorted Array
// find pivot element in sorted and rotated array with duplicates
// Find Minimum in Rotated Sorted Array with duplicates
public int findMin(int[] nums) {
	int n = nums.length;
	if(n == 1) {
	    return nums[0];
	}
	if(nums[0] < nums[n-1]) {
	    return nums[0];
	}
	int start = 0;
	int end = n-1;
	while(end > start) {
	    int mid = start + (end-start)/2;
	    if(nums[mid] == nums[end]) {
		    end--;
	    } else if(nums[mid] > nums[end]) {
		    start = mid+1;
	    } else {
		    end = mid;
	    }
	}
	return nums[end];
}

============


Segment tree using array implementation

int n = arr.length;
int x = (int) Math.ceil( Math.log(n) / Math.log(2) );
int y = (int) Math.pow(2, x);
int treeSize = 2*y - 1;
int tree[] = new int[treeSize];

// divide arr into 2 subarrays [0..(x/2)-1] and [x/2 .. n-1]
// each subarray will return a subresult
// 2 subresults are applied to a function and returned as result



// online majority check using Segment tree, moore algo can also be applied
class MajorityChecker {

    private int arr[];
    private STNode root;

    public MajorityChecker(int[] arr) {
        this.arr = arr;
        root = createST(0, arr.length-1);
    }

    public int query(int left, int right, int threshold) {

        Map<Integer,Integer> map = query(root, left, right);
        for(Integer key : map.keySet()) {
            if(map.get(key).intValue() >= threshold) {
               return key;
            }
        }
        return -1;
    }

    private Map<Integer,Integer> query(STNode node, int low, int high) {
        if(node == null) {
            return new HashMap<>();
        }
        if(node.leftIndex >= low && node.rightIndex <= high) {
            return node.map;
        } else if(node.rightIndex < low || node.leftIndex > high) {
            return new HashMap<>();
        } else {
            Map<Integer,Integer> map1 = query(node.left, low, high);
            Map<Integer,Integer> map2 = query(node.right, low, high);
            return mergeMap(map1, map2);
        }
    }

    class STNode {
        int leftIndex;
        int rightIndex;
        STNode left;
        STNode right;
        Map<Integer,Integer> map = new HashMap<>();

        STNode() {

        }

        STNode(int leftIndex, int rightIndex) {
            this.leftIndex = leftIndex;
            this.rightIndex = rightIndex;
        }
    }

    private STNode createST(int start, int end) {
        if(end < start) {
            return null;
        }
        if(start == end) {
            STNode stNode = new STNode(start, end);
            populateMap(stNode.map, arr[start]);
            return stNode;
        }
        if(end == start + 1) {
            STNode stNode = new STNode(start, end);
            populateMap(stNode.map, arr[start]);
            populateMap(stNode.map, arr[end]);

            STNode leftStNode = new STNode(start, start);
            populateMap(leftStNode.map, arr[start]);
            stNode.left = leftStNode;

            STNode rightStNode = new STNode(end, end);
            populateMap(rightStNode.map, arr[end]);
            stNode.right = rightStNode;

            return stNode;
        }
        int mid = start + (end-start)/2;
        STNode node1 = createST(start, mid);
        STNode node2 = createST(mid+1, end);
        if(node1 == null) {
            return node2;
        }
        if(node2 == null) {
            return node1;
        }
        STNode rootStNode = new STNode(start, end);
        rootStNode.map = mergeMap(node1.map, node2.map);
        rootStNode.left = node1;
        rootStNode.right = node2;
        return rootStNode;
    }

    private void populateMap(Map<Integer,Integer> map, int key) {
        Integer value = map.get(key);
        if(value == null) {
            map.put(key, 1);
        } else {
            map.put(key, value+1);
        }
    }

    private Map<Integer,Integer> mergeMap(Map<Integer,Integer> map1, Map<Integer,Integer> map2) {

        Map<Integer,Integer> mainMap = new HashMap<>();
        Set<Integer> set = new HashSet(map1.keySet());
        set.addAll(map2.keySet());
        for(Integer key : set) {
            Integer value1 = map1.get(key);
            if(value1 == null) {
                value1 = 0;
            }
            Integer value2 = map2.get(key);
            if(value2 == null) {
                value2 = 0;
            }
            mainMap.put(key, value1 + value2);
        }
        return mainMap;
    }
}

-------------------

// minimum broadcast range required by m towers to reach n houses
house[] = {12, 13, 11, 80}
tower[] = {4, 6, 15, 60}

int minBroadcast(int house[], int tower[]) {
    Arrays.sort(house);
    Arrays.sort(tower);
    int n = house.length;
    int m = tower.length;
    int houseIndex = 0;
    int towerIndex = 0;

    int leftTower = Integer.MIN;
    int rightTower = tower[towerIndex];
    int globalMax = 0;

    while(houseIndex < n) {
        if(house[houseIndex] > rightTower) {
            leftTower = rightTower;
            if(towerIndex < m) {
                towerIndex++;
                rightTower = tower[towerIndex];
            } else {
                rightTower = Integer.MAX;
            }
        } else {
            int leftDiff = house[houseIndex] - leftTower;
            int rightDiff = rightTower - house[houseIndex];
            int localMax = Math.min(leftDiff, rightDiff);
            if(localMax > globalMax) {
                globalMax = localMax;
            }
            houseIndex++;
        }
    }
    return globalMax;
}

---------------------

// Lexicographically smallest string formed by removing duplicates
time = O(N)
space = O(N)

String lexicographicallySmallest() {
	int count[] = new int[26];
	boolean visited[] = new boolean[26];

	for(int i=0; i<arr.length; i++) {
		count[arr.charAt(i) - 'a']++;
	}

	String result = "";
	for(int i=0; i<arr.length; i++) {
		char ch = arr.charAt(i);
		count[ch - 'a']--;
		if( !visited[ch - 'a'] ) {
			char temp = result.charAt(result.length()-1);
			while(result.length() > 0 && temp > ch && count[temp - 'a'] > 0) {
				visited[temp - 'a'] = false;
				result = result.substring(0, result.length()-1);
			}
			result = result + ch;
			visited[ch - 'a'] = true;
		}
	}

	return result;
}

---------------------

// check if there is a subarray with 0 sum
create an array of Prefix Sum Array
if any element repeats in Prefix Sum Array, then it has a subarray with 0 sum

---------------------

// Equilibrium index of an array
// an index whose sum of elements at lower indexes is equal to the sum of elements at higher indexes

leftSum = 0
sum = sum of all elements in arr
for every element i in arr {
    leftSum = leftSum + arr[i]
    sum = sum - arr[i]
    if(sum == leftSum) {
        return i;
    }
    return -1;
}

---------------------

// Window Sliding Technique
// Given an array and an integer k, calculate max sum of subarray of k size

-> calculate sum of subarray window 0 to k-1
-> maxSum = subarray_sum(0, k-1)
-> iterate from k to length-1
     subarray_sum = subarray_sum + arr[i] - arr[i-k];
     maxSum = max(subarray_sum, maxSum);

--------------------

// Largest Sum Contiguous Subarray

int maxResult = 0;
int maxEndingHere = 0;

for(int i=0; i<n; i++) {
	maxEndingHere = Math.max(maxEndingHere + arr[i], arr[i]);
	maxResult = Math.max(maxEndingHere, maxResult);
}
return maxResult;

--------------------

// maximum sum subsequence when no two elements are adjacent
// Find maximum possible stolen value from houses

int excl = 0;
int incl = arr[0];
int exclForNext = 0;

for(int i=0; i<n; i++) {
	exclForNext = Math.max(incl, excl);
	incl = excl + arr[i];
	excl = exclForNext;
}
return Math.max(incl, excl);

----------------------------------

interval problems :

=> Approach 1 :
-> two loops
time = O(n^2)


=> Approach 2 : [Interval tree (will only return single conflict)]
-> every node has 3 values (left, right, max_in_right)
-> if root and element intervals conflicts then return root
    -> condition of conflict = (root.left < element.right && element.left < root.right)
-> else if root has left child and root's left child max > element left
    -> then recursively traverse left subtree
-> else recursively traverse left subtree

interval tree creation -- O(nlogn)
search of a conflict   -- O(logn)


=> Approach 3 :
-> taking array of the count of interval timing
-> set initial value to 0
-> add 1 to array slot if interval found
time = O(n)
memory = O(time slots)


=> Approach 4 :
-> sort both arrival and departure arrays
-> take pointers in arrival and departure array
-> count conflicts
time = O(nlogn)
memory = O(n)


=> Approach 5 : (map based approach)
-> keep arr and dep times in a single array
-> arrival times with A, departure times with D
-> sort this array on the basis of time, if times are equal then A first
-> iterate array
    -> if A comes then paltform++
    -> if D comes then paltform--
time = O(nlogn)
memory = O(n)


--------------------------
// print all permutations of an array
public static List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    // Arrays.sort(nums); // not necessary
    backtrack(list, new ArrayList<>(), nums);
    return list;
}

private static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){
    if(tempList.size() == nums.length){
        list.add(new ArrayList<>(tempList));
    } else{
        for(int i = 0; i < nums.length; i++){
            if(tempList.contains(nums[i])) continue; // element already exists, skip
            tempList.add(nums[i]);
            backtrack(list, tempList, nums);
            tempList.remove(tempList.size() - 1);
        }
    }
}

// print all permutations of an array with duplicates
public static List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);
    return list;
}

private static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){
    if(tempList.size() == nums.length){
        list.add(new ArrayList<>(tempList));
    } else{
        for(int i = 0; i < nums.length; i++){
            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;
            used[i] = true;
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, used);
            used[i] = false;
            tempList.remove(tempList.size() - 1);
        }
    }
}

--------------------------

minimum cost jump
https://www.hackerearth.com/problem/algorithm/minimize-cost-3/submissions/
forward jump count = 2
backward jump count = 1
cost of jump from A[i] is A[i]

eg: [1, 2, 3, 4, 100]
output : 1 + 3 + 2 + 4 = 10

long getJumpCost(int arr[]) {
	int length = arr.length;
	if(length < 3) {
        return arr[0];
    }
	long dp[] = new long[length];
	for(int i=0; i<length; i++) {
		dp[i] = Long.MAX_VALUE;
	}
	dp[0] = arr[0];
	dp[2] = dp[0] + (long)arr[2];
	dp[1] = dp[2] + (long)arr[1];
	for(int i=3; i<length; i++) {
		dp[i] = Math.min(dp[i], dp[i-2] + (long)arr[i]);
		dp[i-1] = Math.min(dp[i-1], dp[i] + (long)arr[i-1]);
	}
	long result = Math.min( dp[length-1], dp[length-2]);
	return result;
}


-------------------------------------

// max subarray sum
int maxSubarray(int arr[]) {
	int maxTillNow = 0;
	int maxSum = 0;
	for(int i=0; i<arr.length; i++) {
		maxTillNow = Math.max(maxTillNow + arr[i], arr[i]);
		maxSum = Math.max(maxTillNow, maxSum);
	}
	return maxSum;
}


int arr[] = { -2, -3, 4, -1, -2, 1, 4, -3 };

// max subarray sum with start and end
int maxSubarray(int arr[]) {
	int maxTillNow = 0;
	int maxSum = 0;

	int end = -1;
	int tempStart = -1;
	int start = -1;
	for(int i=0; i<arr.length; i++) {
		if(maxTillNow + arr[i] > arr[i]) {
			maxTillNow = maxTillNow + arr[i];
		} else {
			maxTillNow = arr[i];
			tempStart = i;
		}
		if(maxTillNow > maxSum) {
			maxSum = maxTillNow;
			end = i;
			start = tempStart;
		}
	}
	if(start > -1 && end > -1 && start <= end) {
		// print from start to end
	}
	return maxSum;
}

==================================================

=> Array Rotation
rotate array by d elements
Lexicographically minimum string rotation
Rotate Matrix Elements
Print a given matrix in spiral form
Inplace rotate square matrix by 90 degrees
Check if all rows of a matrix are circular rotations of each other
Minimum rotations required to get the same string
Check if strings are rotations of each other or not
maximum sum in an array without adjacent elements
Count minimum number of fountains to be activated to cover the entire garden
-> Input : arr1 = {2, 3, 10, 6, 4, 8, 1}
   Output : 8
   max diff bw two elements
   larger element appears after smaller element


--Print all subarrays with 0 sum
max sum subarray
max sum subarray without adjacent
max diff in an array of integers, such that A[j] > A[i] and j>i

Find subarray with given sum (Nonnegative Numbers)
Find subarray with given sum (array having negative numbers)
print all permutations of a given string
print all subsequences of a string


=> Array rearrangement
Rearrange an array such that arr[i] = i
Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i
Convert array into Zig-Zag fashion
Rearrange array in alternating positive & negative items with O(1) extra space  -> quick sort logic
Rearrange array such that even positioned are greater than odd
Rearrange an array such that �arr[j]� becomes �i� if �arr[i]� is �j�
Arrange given numbers to form the biggest number
Longest Bitonic Subsequence  -> DP
Longest Bitonic SubArray	-> O(n) time, O(1) space
Maximum Sum Increasing Subsequence (positive numbers)
	->similar to longest increasing subsequence

--Minimum swaps required to bring all elements less than or equal to k together
--Find a sorted subsequence of size 3 in linear time
--Largest subarray with equal number of 0s and 1s



===========================

private static int pivotIncreasing(int start, int end, int arr[]) {
    if(start > end || start == arr.length-1) {
        return -1;
    } else {
        int mid = start + (end-start)/2;
        if(arr[mid] > arr[mid+1]) {
            return mid;
        } else if(arr[start] > arr[mid]) {
            return pivotIncreasing(start, mid-1, arr);
        } else {
            return pivotIncreasing(mid+1, end, arr);
        }
    }
}

private static int pivotDecreasing(int start, int end, int arr[]) {
    if(start > end || start == arr.length-1) {
        return -1;
    } else {
        int mid = start + (end-start)/2;
        if(arr[mid] < arr[mid+1]) {
            return mid;
        } else if(arr[start] < arr[mid]) {
            return pivotDecreasing(start, mid-1, arr);
        } else {
            return pivotDecreasing(mid+1, end, arr);
        }
    }
}


-------------------

//Rearrange an array such that arr[i] = i
int place(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] == -1) {
			i++;
		} else {
			if(arr[i] != i) {
				int temp = arr[arr[i]];
				arr[arr[i]] = arr[i];
				arr[i] = temp;
			} else {
				i++;
			}
		}
	}
}

-------------------

//Move all negative numbers to beginning and positive to end
void moveNegativeToStart(int arr[]) {
	int i=-1;
	int j=0;
	while(j < arr.length) {
		if(arr[j] < 0) {
			i++;
			swap(arr, i, j);
		}
		j++;
	}
}

-------------------

//Rearrange an array such that �arr[j]� becomes �i� if �arr[i]� is �j�
void replace(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] != i) {
			replaceInternal(arr, i);
		} else {
			i++;
		}
	}
}

void replaceInternal(int arr[], int i) {
	if(arr[i] != i) {
		int j = arr[arr[i]];
		arr[i] = i;
		replaceInternal(arr, j);
	}
}

-------------------

//print longest increasing substring
int longestIncreasingSubstring(int arr[]) {
	int max = 1;
	int maxEndingHere = 1;
	int maxStart = 0;
	int maxStartTemp = 0;
	int maxEnd = 0;
	for(int i=1; i<arr.length; i++) {
		if(arr[i] > arr[i-1]) {
			maxEndingHere++;
		} else {
			if(maxEndingHere > max) {
				max = maxEndingHere;
				maxEnd = i-1;
				maxStart = maxStartTemp;
			}
			maxEndingHere = 1;
			maxStartTemp = i;
		}
	}
	if(maxEndingHere > max) {
		max = maxEndingHere;
		maxEnd = arr.length-1;
		maxStart = maxStartTemp;
	}
	System.out.println(maxStart);
	System.out.println(maxEnd);
	return max;
}

-------------------

// longest increasing subsequence

LIS - lis including current index (memoized array)
MAX - max lis found till now (variable)

Arr :	10, 22, 9, 33, 21, 50, 41, 60, 80

LIS :	1	2	1	3	2	4	4	5	6
MAX :	1	2	2	3	3	4	4	5	6


int longestIncreasingSubsequence(int arr[]) {
	int max = 1;
	int LIS[] = new int[arr.length];
	for(int i=0; i<LIS.length; i++) {
		LIS[i] = 1;
	}
	for(int i=1; i<arr.length; i++) {
		for(int j=i-1; j>=0; j--) {
			if(arr[i] > arr[j]) {
				LIS[i] = LIS[j] + 1;
				if(LIS[i] > max) {
					max = LIS[i];
				}
			}
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subsequence
//this is based on longest increasing subsequence
int longestBitonicSubsequence(int arr[]) {
	int lis[] = new int[arr.length];
	int lds[] = new int[arr.length];
	for(int i=0; i<lis.length; i++) {
		lis[i] = 1;
	}
	for(int i=0; i<lds.length; i++) {
		lds[i] = 1;
	}
	for(int i=1; i<lis.length; i++) {
		for(int j=i-1; j>=0; j--) {
			if(arr[i] > arr[j]) {
				lis[i] = lis[j] + 1;
			}
		}
	}
	for(int i=n-2; i>=0; i--) {
		for(int j=i+1; j<arr.length; j++) {
			if(arr[i] > arr[j]) {
				lds[i] = lds[j] + 1;
			}
		}
	}
	int max = 0;
	for(int i=0; i<arr.length; i++) {
		if(lis[i] + lds[i] - 1 > max) {
			max = lis[i] + lds[i] - 1;
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subarray
//	time = O(n)
//	memory = O(n)
int longestBitonicSubarray(int arr[]) {
	int lis[] = new int[arr.length];
	int lds[] = new int[arr.length];
	for(int i=0; i<lis.length; i++) {
		lis[i] = 1;
	}
	for(int i=0; i<lds.length; i++) {
		lds[i] = 1;
	}
	for(int i=1; i<lis.length; i++) {
		if(arr[i] > arr[i-1]) {
			lis[i] = lis[i-1] + 1;
		}
	}
	for(int i=n-2; i>=0; i--) {
		if(arr[i] > arr[i+1]) {
			lds[i] = lds[i+1] + 1;
		}
	}
	int max = 0;
	for(int i=0; i<arr.length; i++) {
		if(lis[i] + lds[i] - 1 > max) {
			max = lis[i] + lds[i] - 1;
		}
	}
	return max;
}

-------------------

//Longest Bitonic Subarray
//	time = O(n)
//	memory = O(1)
int longestBitonicSubarray(int arr[]) {
	int j=0;
	int n = arr.length;
	int start = 0;
	int startNext = 0;
	int max = 0;
	while(j < n) {
		while(j < n-1 && arr[j] <= arr[j+1]) {
			j++;
		}
		while(j < n-1 && arr[j] >= arr[j+1]) {
			if(j < n-1 && arr[j] > arr[j+1]) {
				startNext = j + 1;
			}
			j++;
		}
		if(j - start + 1 > max) {
			max = j - start + 1;
		}
		start = startNext;
	}
	return max;
}

-------------------

// print all subsequences of a string

input : ABC
output : A B C AB AC BC ABC

ABC		->	BC	->	C

A			B		C
AB			BC
ABC			C
AC
B
BC
C



void printAllSubsequences(String arr) {
	List<List<Character>> list = getAllSubsequences(arr.toCharArray(), 0, arr.length-1);
	for(List<Character> characters : list) {
		System.out.println(characters);
	}
}

private List<List<Character>> getAllSubsequences(char arr[], int start, int end) {
	List<List<Character>> returnList = new LinkedList<>();
	List<Character> list = new LinkedList<>();
	list.add(arr[start]);
	returnList.add(list);
	if(end > start) {
		List<List<Character>> recursiveList = getAllSubsequences(arr, start+1, end);
		returnList.addAll(recursiveList);

		List<List<Character>> copiedRecursiveList = new new LinkedList<>(recursiveList);
		for(List temp : copiedRecursiveList) {
			temp.addFirst(arr[start]);
		}
		returnList.addAll(copiedRecursiveList);
	}
	return returnList;
}

-------------------

// sort stack using, pop() push() size() top() methods

void emptyStack(Stack stack) {

	if(stack.size() != 0) {
		int temp = stack.pop();
		emptyStack(stack);
		sortStack(stack, temp);
	}
}

void sortStack(Stack stack, int temp) {
	if(stack.size() != 0) {
		int top = stack.peek();
		if(top <= temp) {
			stack.push(temp);
		} else {
			stack.pop();
			sortStack(stack, temp);
			stack.push(top);
		}
	} else {
		stack.push(temp);
	}
}

-------------------

=> Segment Tree

input array : [1, 3, 5, 7, 9, 11]
segment tree array : [36, 9, 27, 4, 5, 16, 11, 1, 3, 0, 0, 7, 9, 0, 0]

class Node {
	int value;
	int leftLimit;
	int rightLimit;
	Node left;
	Node right;
}

// linked list based binary tree
int getSum(Node treeNode, int low, int high) {
	if(treeNode == null) {
		return 0;
	}
	if(treeNode.leftLimit >= low && treeNode.rightLimit <= high) {
		return treeNode.value;
	}
	if(treeNode.leftLimit > high || treeNode.rightLimit < low) {
		return 0;
	}
	return getSum(treeNode.left, low, high) + getSum(treeNode.right, low, high);
}

// array based binary tree
int getSum(int tree[], int low, int high) {
	//TODO :
}


Node createSegmentTree(int arr[], int start, int end) {
	if(end > start) {
		return null;
	}
	if(start == end) {
		//leaf node
		Node node = new Node(arr[start]);
		node.leftLimit = start;
		node.rightLimit = end;
		return node;
	}
	if(end = start + 1) {
		Node parentNode = new Node(arr[start] + arr[end]);
		parentNode.left = new Node(arr[start]);
		parentNode.right = new Node(arr[end]);
		parentNode.leftLimit = start;
		parentNode.rightLimit = end;
		return parentNode;
	}
	int mid = start + (end-start)/2;
	Node leftNode = createSegmentTree(arr, start, mid);
	Node rightNode = createSegmentTree(arr, mid+1, end);
	if(leftNode == null) {
		return rightNode;
	}
	if(rightNode == null) {
		return leftNode;
	}
	int sum = leftNode.value + rightNode.value;
	Node parentNode = new Node(sum);
	parentNode.left = leftNode;
	parentNode.right = rightNode;
	parentNode.leftLimit = start;
	parentNode.rightLimit = end;
	return parentNode;
}


============================
